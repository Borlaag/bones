;;;; copy-propagation pass


;;; walk expressions and collect an alist mapping variables to known values
;
; - value = '<literal> | <lambda-id> | <symbol> (alias) | '$uninitialized | #f (asigned)
; - expects expression to be canonicalized.
; - inserts "($call ID ...)" expressions

(define (cp1 exp)
  (let ((vars '()))
    (define (atomic? x)
      (or (symbol? x)
	  (char? x)
	  (number? x)
	  (boolean? x)
	  (null? x)))
    (define (assign var val env)
      (match val
	(('quote (? atomic?))
	 (push! (cons var val) vars)
	 #t)
	((? symbol?)
	 (cond ((memq val env)
		(push! (cons var val) vars)
		#t)
	       (else #f)))
	('($uninitialized) 
	 (push! (cons var val) vars)
	 #t)
	(('$lambda id _ _)
	 (push! (cons var id) vars)
	 #t)
	(('$case-lambda id . _)
	 (push! (cons var id) vars)
	 #t)
	(_ #f)))
    (define (walk x env)
      (match x
	((? symbol?) #f)
	(('quote _) #f)
	(((or 'letrec* 'let) ((vrs vals) ...) body)
	 (let* ((env2 (append vrs env))
		(eenv (if (eq? 'letrec* (car x)) env2 env)))
	   (for-each
	    (lambda (var val)
	      (walk val eenv)
	      (assign var val env))
	    vrs vals)
	   (walk body env2)))
	(('begin xs ...)
	 (for-each (cut walk <> env) xs))
	(('$lambda id llist body)
	 (let* ((vars argc rest (parse-lambda-list llist))
		(env2 (append vars env)))
	   (walk body env2)))
	(('$case-lambda id (llists bodies) ...)
	 (for-each
	  (lambda (llist body)
	    (let* ((vars argc rest (parse-lambda-list llist))
		   (env2 (append vars env)))
	      (walk body env2)))
	  llists bodies))
	(('if x y z)
	 (walk x env)
	 (walk y env)
	 (walk z env))
	(('set! var x)
	 (cond ((assq var vars) => 
		(match-lambda
		  ((_ . (and (set! set-val) '($uninitialized)))
		   (unless (assign var x env)
		     (set-val #f)))
		  ((_ . (set! set-val))
		   (set-val #f)))))
	 (walk x env))
	(('define _ x)
	 (walk x env))
	(('$primitive _) #f)
	(('$inline _ xs ...)
	 (for-each (cut walk <> env) xs))
	(('$inline-test _ _ xs ...)
	 (for-each (cut walk <> env) xs))
	(('$allocate _ _ xs ...)
	 (for-each (cut walk <> env) xs))
	((op args ...) (for-each (cut walk <> env) x))
	(_ (error "invalid expression" x))))
    (define (follow var)
      (cond ((assq var vars) => 
	     (lambda (a)
	       (if (cdr a)
		   (follow (cdr a))
		   var)))
	    (else var)))
    (walk exp '())
    ;; now resolve aliases
    (filter-map
     (lambda (a)
       (match a
	 ((var . #f) #f)
	 ((var . '($uninitialized)) #f)
	 ((var . ('quote _)) a)
	 ((var . val) 
	  (cond ((follow val) => (cut cons var <>))
		(else #f)))))
     vars)))


;;; propagate constants and aliased variables
;
; - propagates aliases only in the same lambda.
; - returns transformed expression and items of alist computed in "cp1", that contain lambda-ids.
; - inserts "$call" expressions for calls to known lambdas.

(define (cp exp)
  (let ((vars (cp1 exp))
	(ccount 0))
    (define (walk x lenv env)
      (match x
	((? symbol?) 
	 (cond ((and (memq x env) 
		     (assq x vars)) 
		=> (match-lambda
		     ((_ . (? symbol? var))
		      (cond ((memq var lenv)
			     (inc! ccount)
			     var)
			    (else x)))
		     ((_ . (and y ('quote _)))
		      (inc! ccount)
		      y)
		     (_ x)))
	       (else x)))
	(('quote _) x)
	(((or 'letrec* 'let) ((vars vals) ...) body)
	 (let* ((env2 (append vars env))
		(lenv2 (append vars lenv)))
	   (list (car x)
		 (map
		  (lambda (var val)
		    (list var
			  (if (eq? 'letrec* (car x))
			      (walk val lenv2 env2)
			      (walk val lenv env))))
		  vars vals)
		 (walk body lenv2 env2))))
	(('begin xs ...)
	 `(begin ,@(map (cut walk <> lenv env) xs)))
	(('$lambda id llist body)
	 (let* ((vars argc rest (parse-lambda-list llist))
		(env2 (append vars env)))
	   `($lambda ,id ,llist ,(walk body vars env2))))
	(('$case-lambda id (llists bodies) ...)
	 `($case-lambda
	   ,id
	   ,@(map (lambda (llist body)
		    (let* ((vars argc rest (parse-lambda-list llist))
			   (env2 (append vars env)))
		      (list llist (walk body vars env2))))
		  llists bodies)))
	(('if xs ...)
	 `(if ,@(map (cut walk <> lenv env) xs)))
	(('set! var x)
	 `(set! ,var ,(walk x lenv env)))
	(('define var x)
	 `(define ,var ,(walk x lenv env)))
	(('$primitive _) x)
	(('$inline n xs ...)
	 `($inline ,n ,@(map (cut walk <> lenv env) xs)))
	(('$inline-test n c xs ...)
	 `($inline-test ,n ,c ,@(map (cut walk <> lenv env) xs)))
	(('$allocate t s xs ...)
	 `($allocate ,t ,s ,@(map (cut walk <> lenv env) xs)))
	((op args ...) 
	 (let ((x (map (cut walk <> lenv env) x)))
	   (cond ((and (symbol? op) (assq op vars)) =>
		  (lambda (a)
		    (if (number? (cdr a))
			`($call ,(cdr a) ,@x)
			x)))
		 (else x))))
	(_ (error "invalid expression" x))))
    (let ((exp (walk exp '() '())))
      (NB "  propagated " ccount " variable values")
      exp)))
